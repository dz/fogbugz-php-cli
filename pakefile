<?php

pake_desc('Check the code for psr2 standards');
pake_task('sniff', 'fixer');

pake_desc('Run php-cs-fixer on the src directory');
pake_task('fixer');

pake_desc('Update the README with the latest command output');
pake_task('readme');

pake_desc('Build phar file');
pake_task('phar', 'sniff');

pake_alias('default', 'phar');

function run_phar()
{
    passthru(
        'rm -f fb && '
        . 'php -dphar.readonly=0 build/empir make fb.phar working.php . --exclude="'
        . '*.git/*|*.gitignore|*test*|*Tests*|*.md|*/doc/*|*.lock|*token.txt|pakefile'
        . '|.*|build/*|*.markdown|*.phar|*LICENSE|*AUTHORS|*CHANGELOG'
        . '" && chmod a+x fb.phar'
        . ' && mv fb.phar fb'
    );
}

function run_sniff()
{
    passthru("phpcs -p --standard=PSR2 ./src/ ./working.php");
}

function run_fixer()
{
    passthru(
        "php-cs-fixer fix ./working.php"
        . " && php-cs-fixer fix ./src/FogBugz/Cli/"
        . " && php-cs-fixer fix ./src/FogBugz/Command/"
    );
}

function run_readme()
{
    $readme = file("README.md");
    $help = explode("\n", shell_exec("php ./working.php list"));

    $helpStart = $helpEnd = 0;
    foreach ($readme as $lineNumber => $line) {
      if (trim($line) == "## Help") {
          $helpStart = $lineNumber;
      }
      if ($helpStart && (substr(trim($line), 0, 2) == "##")) {
          $helpEnd = $lineNumber;
          break;
      }
    }

    $output = join(array_slice($readme, 0, $helpStart + 1));
    $output .= "\n    " . implode("\n    ", $help) . "\n";
    $output .= join(array_slice($readme, $helpEnd));

    file_put_contents("README.md", $output);
}

/* End of pakefile */
